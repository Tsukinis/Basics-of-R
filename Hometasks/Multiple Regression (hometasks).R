'''
Напишите функцию fill_na, которая принимает на вход данные с тремя переменными:

x_1  -  числовой вектор

x_2 - числовой вектор

y - числовой вектор с пропущенными значениями.

Теперь — самое интересное. На первом этапе, используя только наблюдения, в которых нет пропущенных значений, мы построим регрессионную модель (без взаимодействий), где  y — зависимая переменная, x_1 и x_2 — независимые переменные. Затем, используя построенную модель, мы заполним пропущенные значения предсказаниями модели.

Функция должна возвращать dataframe c новой переменной  y_full. Сохраните в нее переменную y, в которой пропущенные значения заполнены предсказанными значениями построенной модели.
'''

fill_na <- function(test_data){
  # находим линейную регрессию 
  r <- lm(y ~ x_1 + x_2, test_data)
  
  # копируем переменную
  y_full <- test_data$y
  
  # находим позиции пропущенных значений
  empty <- which(is.na(y_full))
  
  # и подставляем значения, соответствующие регрессии
  y_full[empty] <- predict(r, test_data)[empty]
  
  # добавляем переменную в датасет и возвращаем
  test_data$y_full <- y_full
  return(test_data)
}

'''
В переменной df сохранен subset данных mtcars только с переменными "wt", "mpg", "disp", "drat", "hp". Воспользуйтесь множественным регрессионным анализом, чтобы предсказать вес машины (переменная "wt"). Выберите такую комбинацию независимых переменных (из "mpg", "disp", "drat", "hp"), чтобы значение R^2 adjusted было наибольшим. Взаимодействия факторов учитывать не надо. 
'''
df1 <- mtcars[,c("wt", "mpg", "disp", "drat", "hp")]
fit_full <- lm(wt ~ ., data = df1)
optimal_fit <-  step(fit_full, direction = 'backward')
opt_summary <- summary(optimal_fit)
attr(as.formula(opt_summary), "term.labels")

'''
Визуализируйте взаимодействие переменных wt и am, дополнив код, приведённый в задании:
Ось x - переменная wt
Ось y - переменная mpg
Цвет регрессионных прямых - переменная am
'''
library(ggplot2)
# сначала переведем переменную am в фактор
mtcars$am <- factor(mtcars$am)

# теперь строим график
my_plot <- ggplot(mtcars, aes(x = wt, y = mpg, col = am))+
  geom_smooth(method = 'lm')

'''
model_full - модель, которая предсказывает значение переменной рейтинг (rating) в зависимости от всех остальных переменных в данном датасете.

model_null - модель, в которой нет ни одного предиктора, а есть только intercept. Значение intercept - это просто среднее значение зависимой переменной. Соответственно, модель предоставляет нам информацию только о том, отличается ли это среднее от нуля.
Итак, задача! C помощью функции step найдите оптимальную модель для предсказания rating в датасете attitude. Model_full и model_null уже созданы. Сохраните команду с функцией step в переменную ideal_model.
'''
ideal_model <- step(model_full, scope = list(lower = model_null, upper = model_full), direction = c("both", "backward", "forward"))

'''
Сравните полную модель из предыдущего степа и оптимальную модель с помощью функции anova. Введите получившееся F-значение.
'''
anova(ideal_model, model_full)

'''
Напоследок потренируемся в эффективном написании формул. 
В этой задаче будем работать со встроенным датасетом LifeCycleSavings. 
Попытаемся предсказать значение sr на основе всех остальных переменных в этом датасете. Вспомните способы сокращения формул и напишите команду, которая создаёт линейную регрессию с главными эффектами и всеми возможными взаимодействиями второго уровня. Сохраните модель в переменную model.
'''
model <- lm(sr ~ (.)*(.), data = LifeCycleSavings)
