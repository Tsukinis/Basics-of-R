'''
В переменной my_vector хранится вектор значений.

my_vector <- c(0.027, 0.079, 0.307, 0.098, 0.021, 0.091, 0.322, 0.211, 0.069, 0.261, 0.241, 0.166, 0.283, 0.041, 0.369, 0.167, 0.001, 0.053, 0.262, 0.033, 0.457, 0.166, 0.344, 0.139, 0.162, 0.152, 0.107, 0.255, 0.037, 0.005, 0.042, 0.220, 0.283, 0.050, 0.194, 0.018, 0.291, 0.037, 0.085, 0.004, 0.265, 0.218, 0.071, 0.213, 0.232, 0.024, 0.049, 0.431, 0.061, 0.523)
Какое преобразование позволяет сделать его распределение нормальным (согласно shapiro.test)?

'''

shapiro.test(my_vector)
shapiro.test(sqrt(my_vector)) # наш ответ
shapiro.test(log(my_vector))
shapiro.test(1 / my_vector) 

'''
Функция scale() позволяет совершить стандартизацию вектора, то есть делает его среднее значение равным нулю, а стандартное отклонение - единице (Z-преобразование).

Стандартизованный коэффициент регрессии (\betaβ) можно получить, если предикторы и зависимая переменная стандартизованы.

Напишите функцию, которая на вход получает dataframe с двумя количественными переменными, а возвращает стандартизованные коэффициенты для регрессионной модели, в которой первая переменная датафрейма выступает в качестве зависимой, а вторая в качестве независимой.
'''

beta.coef <- function(x)
  {
  return (lm(scale(x[[1]]) ~ scale(x[[2]]), x)$coefficients)
}

'''
Напишите функцию normality.test, которая получает на вход dataframe с количественными переменными, проверяет распределения каждой переменной на нормальность с помощью функции shapiro.test. Функция должна возвращать вектор с значениями p - value, полученного в результате проверки на нормальность каждой переменной. Названия элементов вектора должны совпадать с названиями переменных. 
'''
normality.test  <- function(x)
  {    
  return(sapply(x, FUN =  shapiro.test)['p.value',])
}

'''
Функция gvlma() из библиотеки gvlma позволяет получить оценку выполнения основных допущений линейной регрессии. В качестве аргумента она принимает объект, в который сохранена модель. Можно задать формулу модели прямо в функции gvlma. Чтобы увидеть основные статистики, нужно выполнить команду summary для объекта, созданного с помощью функции gvlma.
Загрузите себе прикреплённый к этому степу датасет и постройте регрессию, предсказывающую DV по IV. Установите библиотеку gvlma и проверьте, удовлетворяется ли в этой модели требование гомоскедастичности. Введите в поле ответа p-значение для теста гетероскедастичности.
'''
install.packages("gvlma")
library(gvlma)

mydata <- read.csv('~/RScripts/Datasets/homosc.csv')
x <- gvlma(DV ~ IV, data = mydata)
summary(x)

'''
Напишите функцию resid.norm, которая тестирует распределение остатков от модели на нормальность при помощи функции shapiro.test и создает гистограмму при помощи функции ggplot() с красной заливкой "red", если распределение остатков значимо отличается от нормального (p < 0.05), и с зелёной заливкой "green" - если распределение остатков значимо не отличается от нормального.
На вход функция получает регрессионную модель. Функция возвращает переменную, в которой сохранен график ggplot.
В поле для ответа не нужно создавать никаких дополнительных объектов, только напишите функцию  resid.norm.
'''
resid.norm  <- function(fit)
  {
  color <- ifelse(shapiro.test(fit$resid)$p.value < 0.05, "red", "green")
  ggplot(data.frame(fit$residuals), aes(x = fit$residuals)) + 
    geom_histogram(fill = color)
}

'''
Задача для супергероев!!!

Ещё одной проблемой регрессионных моделей может стать мультиколлинеарность - ситуация, когда предикторы очень сильно коррелируют между собой. Иногда корреляция между двумя предикторами может достигать 1, например, когда два предиктора - это одна и та же переменная, измеренная в разных шкалах (x1 - рост в метрах, x2 - рост в сантиметрах)  

Проверить данные на мультиколлинеарность можно по графику pairs() и посчитав корреляцию между всеми предикторами c помощью функции cor.

Напишите функцию high.corr, которая принимает на вход датасет с произвольным числом количественных переменных и возвращает вектор с именами двух переменных с максимальным абсолютным значением коэффициента корреляции .
'''
high.corr <- function(x)
  {
  df <- cor(x)
  diag(df) <- 0
  df <- abs(df)
  df <- round(df, digits = 4)
  ind <- which(df == max(df), arr.ind = TRUE)
  return(rownames(ind))
}