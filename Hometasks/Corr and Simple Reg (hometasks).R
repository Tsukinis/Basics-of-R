'''
Напишите функцию corr.calc, которая на вход получает data.frame с двумя количественными переменными,
рассчитывает коэффициент корреляции Пирсона и возвращает вектор из двух значений: коэффициент корреляции и p - уровень значимости.
'''
library(psych)

corr.calc <- function(test_data)
  {   
  
  fit  <- cor.test(test_data[[1]], test_data[[2]])    
  r <- fit$estimate    
  p <- fit$p.value    
  return(c(r, p))
  
}

'''
Напишите функцию filtered.cor которая на вход получает data.frame с  произвольным количеством переменных (как количественными, так и любых других типов), рассчитывает коэффициенты корреляции Пирсона между всеми парами количественных переменных и возвращает наибольшее по модулю значение коэффициента корреляции. 
(То есть функция может вернуть -0.9, если это наибольшая по модулю  корреляция).
Гарантируется наличие в data.frame хотя бы двух количественных переменных.
Обратите внимание: при проверке вашей функции на вход будут подаваться данные с различными именами колонок. 
Ваша функция должна корректно работать независимо от имен переменных. Перед тем, как сдавать решение, убедитесь, что ваша функция работает корректно на разных данных, с разными именами колонок.
'''

filtered.cor <- function(x)
  {
  
  res <- x[, sapply(x, is.numeric)]
  res <- cor(res, method = "pearson", use = "complete.obs")
  diag(res) <- 0
  res[which.max(abs(res))]
  
}

'''
Напишите функцию smart_cor, которая получает на вход dataframe с двумя количественными переменными. 
Проверьте с помощью теста Шапиро-Уилка, что данные в обеих переменных принадлежат нормальному распределению.
Если хотя бы в одном векторе распределение переменной отличается от нормального (p - value меньше 0.05), то функция должна возвращать коэффициент корреляции Спирмена.
(Числовой вектор из одного элемента).
Если в обоих векторах распределение переменных от нормального значимо не отличается, то функция должна возвращать коэффициент корреляции Пирсона.
'''
smart_cor <- function(x)
{
  
  if(shapiro.test(x[[1]])$p.value < 0.05 | shapiro.test(x[[2]])$p.value < 0.05)
  {
    res <- cor.test(x[[1]], x[[2]], method = "spearman")$estimate
    
  } else {
    res <- cor.test(x[[1]], x[[2]])$estimate
  }
  res
  
}

'''
Скачайте набор данных - dataframe с двумя количественными переменными (вспомните при необходимости, как задавать разделитель и другие параметры функции read.table), постройте линейную регрессию,
где - первая переменная - зависимая, вторая - независимая. В ответ укажите значения регрессионных коэффициентов сначала intercept затем  slope.
'''
df <- read.table("~/RScripts/Datasets/dataset_11508_12 (1).txt", sep=' ')    
data_1 <- lm(df[,1]~ df[,2], df)
print(data_1$coefficients)

'''
Воспользуемся уже знакомыми данными diamonds из библиотеки ggplot2. Только для бриллиантов класса Ideal (переменная cut) c числом карат равным 0.46 (переменная carat) постройте линейную регрессию, где в качестве зависимой переменной выступает price, в качестве предиктора - переменная  depth.
Сохраните коэффициенты регрессии в переменную fit_coef.
'''

data_for_model <- subset(diamonds, cut == 'Ideal' & carat == 0.46)    
fit <- lm(price ~ depth, data_for_model)    
fit_coef <- fit$coefficients

'''
Напишите функцию regr.calc, которая на вход получает dataframe c двумя переменными.
Если две переменные значимо коррелируют (p - уровень значимости для коэффициента корреляции Пирсона меньше 0.05), то функция строит регрессионную модель, где первая переменная - зависимая, вторая - независимая.
Затем создает в dataframe новую переменную с назанием fit, где сохраняет предсказанные моделью значения зависимой переменной. В результате функция должна возвращать исходный dataframe с добавленной новой переменной fit.
Если две переменные значимо не коррелируют, то функция возвращает строчку "There is no sense in prediction"
Обратите внимание, при проверке вашей функции на вход будут подаваться данные с различными именами колонок. 
Ваша функция должна корректно работать в независимости от имен переменных.
'''

regr_calc <- function(sample_data)
{    
  cor_result = cor.test(~sample_data[[1]] + sample_data[[2]])    
  if (cor_result$p.value < 0.05){    
    fit_model  <- lm(sample_data[[1]] ~ sample_data[[2]])    
    sample_data$fit  <- fit_model$fitted.values    
    return(sample_data)    
  } else {    
    return('There is no sense in prediction')}
}

'''
Постройте scatterplot по данным iris, сохранив его в переменную my_plot : 
Ось X - переменная Sepal.Width
Ось Y -  переменная Petal.Width
Цвет точек - переменная Species
Также добавьте линейное сглаживание для каждой группы наблюдений по переменной Species.
'''
library(ggplot2)

my_plot <- ggplot(iris, aes(Sepal.Width, Petal.Width,
                            col = Species, xlab = "Sepal.Width", ylab = "Petal.Width"))+ geom_point()+ 
                            geom_smooth(method = "lm")



