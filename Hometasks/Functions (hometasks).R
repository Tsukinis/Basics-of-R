'''
Напишите функцию, которая выводит номера позиций пропущенных наблюдений в векторе.

На вход функция получает числовой вектор с пропущенными значениями. Функция возвращает новый вектор с номерами позиций пропущенных значений.

Подсказка: чтобы проверить является ли наблюдение NA, воспользуйтесь функцией is.na(), кстати, функция векторизирована, и аргументом может служить вектор произвольной длинны. Запись x == NA ни к чему осмысленному не приведет. Т.к. если x это NA, то команда x == NA также вернет NA, а не TRUE!
'''
NA.position <- function(x){
  
  res <- which(is.na(x))
  
}

'''
Напишите функцию NA.counter для подсчета пропущенных значений в векторе.

На вход функция  NA.counter должна принимать один аргумент - числовой вектор. Функция должна возвращать количество пропущенных значений.
'''
NA.counter <- function(x){    
  return(sum(is.na(x)))
}

'''
Напишите функцию filtered.sum, которая на вход получает вектор с пропущенными, положительными и отрицательными значениями и возвращает сумму положительных элементов вектора.
'''
filtered.sum <- function(x){    
  return(sum(x[x > 0], na.rm = T))
}

'''
Задача для героев!

Напишите функцию outliers.rm, которая находит и удаляет выбросы. Для обнаружения выбросов воспользуемся самым простым способом, с которым вы не раз встречались, используя график Box plot. 

Выбросами будем считать те наблюдения, которые отклоняются от 1 или 3 квартиля больше чем на 1,5 *  IQR, где  IQR  - межквартильный размах.

На вход функция получает числовой вектор x. Функция должна возвращать модифицированный вектор x с удаленными выбросами. 
'''
outliers.rm <- function(x){
  # put your code here  
  ind1 <- which(x < quantile(x, probs = c(0.25)) - 1.5*IQR(x))
  ind2 <- which(x > quantile(x, probs = c(0.75)) + 1.5*IQR(x))
  x <- x[-c(ind1,ind2)]
}
